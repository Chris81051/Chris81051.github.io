<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris&#39;s Lab</title>
  
  <subtitle>If you obey all the rules,you miss all the fun.</subtitle>
  <link href="https://chris81051.github.io/atom.xml" rel="self"/>
  
  <link href="https://chris81051.github.io/"/>
  <updated>2024-01-21T08:03:47.000Z</updated>
  <id>https://chris81051.github.io/</id>
  
  <author>
    <name>Chris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新北 | 汐止 | 夜景　聖德宮</title>
    <link href="https://chris81051.github.io/2024/01/21/Travel-Xizhi-Shengde-Temple/"/>
    <id>https://chris81051.github.io/2024/01/21/Travel-Xizhi-Shengde-Temple/</id>
    <published>2024-01-21T08:03:47.000Z</published>
    <updated>2024-01-21T08:03:47.000Z</updated>
    
    <content type="html"><![CDATA[<a class="travel-image-link" href="https://chris81051.github.io/2024/01/21/Travel-Xizhi-Shengde-Temple" target="_self">  <img src="https://i.imgur.com/t6lnV2p.jpg" title="聖德宮" width="85%" high="85%"></a><span id="more"></span><p class="travel-image-title">聖德宮　f/1.8　1/4s　ISO-800　by Chris</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>平常是個大家來拜拜的地方，許多人白天來是為了拍日式神社的拱門網美照，可以挑傍晚的時間來，不過晚上來也有不錯的夜景看，面向南港的方向看的到小小的101。</p><h3 id="行前概要"><a href="#行前概要" class="headerlink" title="行前概要"></a>行前概要</h3><hr><p>上山的路途有點陡峭，廟方有自己的停車場可以停汽機車相當方便，但需要注意的是晚上六點會管制車輛進出，車子無法進出，不過管制的柵欄夠讓機車通過。</p><h3 id="攝影點"><a href="#攝影點" class="headerlink" title="攝影點"></a>攝影點</h3><hr><p>座標：<a href="https://maps.app.goo.gl/Yyxgyx9fEfDNtejU9">25.05449, 121.66502</a></p><p>街景：<a href="https://maps.app.goo.gl/ArfzWQ24Zo6mQMV98">https://maps.app.goo.gl/ArfzWQ24Zo6mQMV98</a></p><h3 id="停車點"><a href="#停車點" class="headerlink" title="停車點"></a>停車點</h3><hr><p>廟方停車場：<a href="https://maps.app.goo.gl/4mwKiuk423zCisJ47">25.05447, 121.66475</a></p><p>街景：<a href="https://maps.app.goo.gl/vTfX4BsAGVpWbiYE7">https://maps.app.goo.gl/vTfX4BsAGVpWbiYE7</a></p>]]></content>
    
    
    <summary type="html">&lt;a class=&quot;travel-image-link&quot; href=&quot;https://chris81051.github.io/2024/01/21/Travel-Xizhi-Shengde-Temple&quot; target=&quot;_self&quot;&gt;
  &lt;img src=&quot;https://i.imgur.com/t6lnV2p.jpg&quot; title=&quot;聖德宮&quot; width=&quot;85%&quot; high=&quot;85%&quot;&gt;
&lt;/a&gt;</summary>
    
    
    
    <category term="新北" scheme="https://chris81051.github.io/categories/%E6%96%B0%E5%8C%97/"/>
    
    <category term="汐止" scheme="https://chris81051.github.io/categories/%E6%96%B0%E5%8C%97/%E6%B1%90%E6%AD%A2/"/>
    
    
    <category term="山區" scheme="https://chris81051.github.io/tags/%E5%B1%B1%E5%8D%80/"/>
    
    <category term="夜景" scheme="https://chris81051.github.io/tags/%E5%A4%9C%E6%99%AF/"/>
    
    <category term="約會" scheme="https://chris81051.github.io/tags/%E7%B4%84%E6%9C%83/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 34. Find First and last Position of Element in Sorted Array</title>
    <link href="https://chris81051.github.io/2024/01/21/Leetcode-34-Find-First-and-last-Position-of-Element-in-Sorted-Array-Java-Python/"/>
    <id>https://chris81051.github.io/2024/01/21/Leetcode-34-Find-First-and-last-Position-of-Element-in-Sorted-Array-Java-Python/</id>
    <published>2024-01-21T06:12:07.000Z</published>
    <updated>2024-01-21T06:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題標準運用了二分搜尋法，演算法通常需要使用二分思想，即每次能夠排除一半的範圍，快速的找出陣列中所要求的元素位置，這樣時間複雜度可達 <code>O(log n)</code>，時間複雜度可達 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.<br>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.<br>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p></blockquote><blockquote><p>給定一個不是降序過後的整數陣列 <code>nums</code>，找到目標值的開始和結束的位置。<br>如果在陣列裡找不到目標，回傳 <code>[-1, -1]</code>。<br>你必須寫出一個時間複雜度 <code>O(log n)</code> 的算法。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>0 &lt;= nums.length &lt;= 105</code><br><code>109 &lt;= nums[i] &lt;= 109</code><br><code>nums</code> is a non-decreasing array.<br><code>109 &lt;= target &lt;= 109</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>目標值是 8，所以在陣列裡開始和結束的位置是 3 和 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">Output: [-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [], target = <span class="number">0</span></span><br><span class="line">Output: [-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><ol><li>設計兩個函數 <code>findFirst</code> 、 <code>findLast</code> 來取得第一個和最後一個符合 target 值的索引。</li><li>兩個函數內都運用了二分搜尋法來找到正確的索引。</li><li>findFirst 函數：<ul><li>如果目標元素 <code>target</code> 小於等於 <code>nums[mid]</code>，則將 <code>end</code> 更新為 <code>mid - 1</code>。</li><li>如果目標元素 <code>target</code> 大於 <code>nums[mid]</code>，則將 <code>start</code> 更新為 <code>mid + 1</code>。</li><li>在找到目標元素時，將 <code>idx</code> 設定為 <code>mid</code>。</li><li>確保在找到目標元素時繼續向左搜尋，以找到第一次出現的位置。</li></ul></li><li>findLast 函數：<ul><li>如果目標元素 <code>target</code> 大於等於 <code>nums[mid]</code>，則將 <code>start</code> 更新為 <code>mid + 1</code>。</li><li>如果目標元素 <code>target</code> 小於 <code>nums[mid]</code>，則將 <code>end</code> 更新為 <code>mid - 1</code>。</li><li>在找到目標元素時，將 <code>idx</code> 設定為 <code>mid</code>。</li><li>確保在找到目標元素時繼續向右搜尋，以找到最後一次出現的位置。</li></ul></li></ol><p>[注意點] 之所以要用上述中間值的寫法會比較安全，因如果 start 和 end 趨近於最大數時，兩者相加起來的合可能會造成整數溢位</p><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        result[<span class="number">0</span>] = findFirst(nums, target); <span class="comment">// target 第一次出現的位置</span></span><br><span class="line">        result[<span class="number">1</span>] = findLast(nums, target); <span class="comment">// target 最後一次出現的位置</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 回傳值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 起點位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 終點位置</span></span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>; <span class="comment">// 中位數</span></span><br><span class="line">            <span class="comment">// 一直往陣列的左側找到底，找到第一次出現的位置</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt;= nums[mid])&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>; <span class="comment">// 重新定義終點，下次回圈找到新的終點停止</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>; <span class="comment">// 重新定義起點，下次回圈從新的起點開始</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123; <span class="comment">// 陣列裡確定有 target</span></span><br><span class="line">                idx = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLast</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">           <span class="comment">// 一直往陣列的右側找到底，找到最後一次出現的位置</span></span><br><span class="line">           <span class="keyword">if</span>(target &gt;= nums[mid])&#123;</span><br><span class="line">               start = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               end = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(target == nums[mid])&#123;</span><br><span class="line">               idx = mid;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [self.findFirst(nums, target), self.findLast(nums, target)]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findFirst</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        idx = -<span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt;= nums[mid]:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> target == nums[mid]:</span><br><span class="line">                idx = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLast</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        idx = -<span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[mid]:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> target == nums[mid]:</span><br><span class="line">                idx = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>0ms</td><td>45.74MB</td></tr><tr><td>Python</td><td>75ms</td><td>17.81MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題用的技巧是二分搜尋法，原理是每次循環都會將搜索範圍縮小一半。</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Binary Search" scheme="https://chris81051.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>新北 | 汐止 | 夜景　小南港山</title>
    <link href="https://chris81051.github.io/2023/11/25/Travel-Xiaonangang-Mountain/"/>
    <id>https://chris81051.github.io/2023/11/25/Travel-Xiaonangang-Mountain/</id>
    <published>2023-11-25T07:49:30.000Z</published>
    <updated>2023-11-25T07:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<a class="travel-image-link" href="https://chris81051.github.io/2023/11/25/Travel-Xiaonangang-Mountain" target="_self">  <img src="https://i.imgur.com/A43sM4h.jpg" title="小南港山" width="85%" high="85%"></a><span id="more"></span><p class="travel-image-title">小南港山　f/1.8　1/15s　ISO-500　by Chris</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　台北夜景之一，可以看的到南港軟體工業園區的金融大樓，還有在旁的南港聯絡快速道路，抵達目在廟的旁邊，而且有石頭桌椅可坐著休息，筆者當天晚上去的時候蚊蟲不多，有些許涼風。</p><h3 id="行前概要"><a href="#行前概要" class="headerlink" title="行前概要"></a>行前概要</h3><hr><p>　　捷運站到登山口的距離還滿遠的，路程大約 15 分鐘，汽車停車場距離目的地有點遠，但在水溝的對面可路邊停車，可以走行人陸橋過水溝，但晚上的時候非常暗沒有路燈，機車停車的話可以停在登山入口的入口，爬山需要爬樓梯，爬山路程大約 20 分鐘可抵達拍照點，上山有少許路燈不算太陰暗。</p><h3 id="登山口"><a href="#登山口" class="headerlink" title="登山口"></a>登山口</h3><hr><p>座標：<a href="https://maps.app.goo.gl/uoWURsQitiQf91XK6">25.05452, 121.62170</a><br>街景：<a href="https://maps.app.goo.gl/1quBcvq1E9kxBTL17">https://maps.app.goo.gl/1quBcvq1E9kxBTL17</a></p><h3 id="攝影點"><a href="#攝影點" class="headerlink" title="攝影點"></a>攝影點</h3><hr><p>座標：<a href="https://maps.app.goo.gl/vTh8FQVAidjnYVtp6">25.05374, 121.62255</a><br>街景：<a href="https://maps.app.goo.gl/Vgur7V4g2dKz2PPv5">https://maps.app.goo.gl/Vgur7V4g2dKz2PPv5</a></p><h3 id="搭車點"><a href="#搭車點" class="headerlink" title="搭車點"></a>搭車點</h3><hr><p>南港展覽館站 6 號出口：<a href="https://maps.app.goo.gl/qVYVWcHLM8ESXzeH7">25.05483, 121.61781</a><br>街景：<a href="https://maps.app.goo.gl/NwVtS491xE9XtYMm8">https://maps.app.goo.gl/NwVtS491xE9XtYMm8</a></p><h3 id="停車點"><a href="#停車點" class="headerlink" title="停車點"></a>停車點</h3><hr><p>捷運站旁停車場：<a href="https://maps.app.goo.gl/66TvedLoXevS8Tpd6">25.05532, 121.61886</a><br>街景：<a href="https://maps.app.goo.gl/oUtD34NFwi79LeQZA">https://maps.app.goo.gl/oUtD34NFwi79LeQZA</a></p><p>汽車路邊停車：<a href="https://maps.app.goo.gl/4sD73VuF24Mp6fYn8">25.05418, 121.62058</a><br>街景：<a href="https://maps.app.goo.gl/oXfZ4NFbcvBRkfmR6">https://maps.app.goo.gl/oXfZ4NFbcvBRkfmR6</a></p><p>機車路邊停車：<a href="https://maps.app.goo.gl/uoWURsQitiQf91XK6">25.05452, 121.62170</a><br>街景：<a href="https://maps.app.goo.gl/1quBcvq1E9kxBTL17">https://maps.app.goo.gl/1quBcvq1E9kxBTL17</a></p>]]></content>
    
    
    <summary type="html">&lt;a class=&quot;travel-image-link&quot; href=&quot;https://chris81051.github.io/2023/11/25/Travel-Xiaonangang-Mountain&quot; target=&quot;_self&quot;&gt;
  &lt;img src=&quot;https://i.imgur.com/A43sM4h.jpg&quot; title=&quot;小南港山&quot; width=&quot;85%&quot; high=&quot;85%&quot;&gt;
&lt;/a&gt;</summary>
    
    
    
    <category term="新北" scheme="https://chris81051.github.io/categories/%E6%96%B0%E5%8C%97/"/>
    
    <category term="汐止" scheme="https://chris81051.github.io/categories/%E6%96%B0%E5%8C%97/%E6%B1%90%E6%AD%A2/"/>
    
    
    <category term="山區" scheme="https://chris81051.github.io/tags/%E5%B1%B1%E5%8D%80/"/>
    
    <category term="夜景" scheme="https://chris81051.github.io/tags/%E5%A4%9C%E6%99%AF/"/>
    
    <category term="約會" scheme="https://chris81051.github.io/tags/%E7%B4%84%E6%9C%83/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 198. House Robber</title>
    <link href="https://chris81051.github.io/2023/11/14/LeetCode-198-House-Robber-Java-Python/"/>
    <id>https://chris81051.github.io/2023/11/14/LeetCode-198-House-Robber-Java-Python/</id>
    <published>2023-11-14T07:59:41.000Z</published>
    <updated>2023-11-14T07:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題是一題動態規劃問題，目標是擷取不連續的元素，全部相加起來選出最優解，因只用了一層迴圈，時間複雜度可估 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p></blockquote><blockquote><p>你是一個專業的小偷，計畫了搶劫街道上的房子，每個房子藏有一定數量的錢，阻止你的唯一條件是房子之間有相連的安全系統，如果相連的房子同一晚被闖入，就會通知警方。</p><p>給定一個整數陣列 <code>nums</code> 代表每一間房子的金額，回傳擷取最高的金額且沒有驚動警察。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/house-robber/">https://leetcode.com/problems/house-robber/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= nums.length &lt;= 100</code><br><code>0 &lt;= nums[i] &lt;= 400</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</span><br><span class="line">Total amount you <span class="type">can</span> <span class="variable">rob</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">3</span> = <span class="number">4.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">12</span></span><br><span class="line">Explanation: Rob house <span class="number">1</span> (money = <span class="number">2</span>), rob house <span class="number">3</span> (money = <span class="number">9</span>) and rob house <span class="number">5</span> (money = <span class="number">1</span>).</span><br><span class="line">Total amount you <span class="type">can</span> <span class="variable">rob</span> <span class="operator">=</span> <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12.</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><ul><li>擷取不連續的元素，全部相加起來，這歸類在動態規劃的想法，是利用先前的計算結果來推導目前的最優解。</li><li>我們將兩個變數 rob 和 notrob，分別表示如果搶當前房屋和不搶當前房屋時，能夠得到的最大金額。</li><li>在遍歷每個房屋時，透過更新這兩個變數，計算出最終的最大金額。</li></ul><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 搶當前的房子的最大金額</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">notrob</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 不搶當前的房子的最大金額</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currob</span> <span class="operator">=</span> notrob + nums[i]; <span class="comment">// 0 + 當前房子 (如果搶了當前房子就不能搶前一個房子)</span></span><br><span class="line">        notrob = Math.max(notrob, rob); <span class="comment">// 不搶當前的房子和搶當前的房子比較 (因為在不搶目前房屋的情況下，可以選擇搶或不搶上一個房屋，所以要取最大值)</span></span><br><span class="line">        rob = currob; <span class="comment">// 搶當前的房子的最大金額</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(rob, notrob); <span class="comment">// 最後選出最大的金額</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        rob = <span class="number">0</span></span><br><span class="line">        not_rob = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur_rob = not_rob + num</span><br><span class="line">            not_rob, rob = <span class="built_in">max</span>(not_rob, rob), cur_rob</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob, not_rob)</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>0ms</td><td>40.62MB</td></tr><tr><td>Python</td><td>48ms</td><td>16.33MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題是一題動態規劃問題，目標是擷取不連續的元素，全部相加起來選出最優解</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Dynamic Programming" scheme="https://chris81051.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>台北 | 中山 | 夜景　微風平台</title>
    <link href="https://chris81051.github.io/2023/10/29/Travel-Taipei-Zhongshan-night-view-Breeze-platform/"/>
    <id>https://chris81051.github.io/2023/10/29/Travel-Taipei-Zhongshan-night-view-Breeze-platform/</id>
    <published>2023-10-29T13:20:21.000Z</published>
    <updated>2023-10-29T13:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<a class="travel-image-link" href="https://chris81051.github.io/2023/10/29/Travel-Taipei-Zhongshan-night-view-Breeze-platform" target="_self">  <img src="https://i.imgur.com/53wozHT.jpg" title="微風平台" width="85%" high="85%"></a><span id="more"></span><p class="travel-image-title">微風平台　f/1.8　1/4s　ISO-250　by Chris</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　台北夜景之一，可俯瞰台北表演藝術中心，附近有士林夜市可逛，而且劍潭捷運站在旁邊交通很方便。</p><h3 id="行前概要"><a href="#行前概要" class="headerlink" title="行前概要"></a>行前概要</h3><hr><p>　　捷運站到登山口路程大約 10 分鐘，周邊有汽車停車場，機車停車可停在登山口路邊但位子較少，爬山需要爬樓梯，前段路途有點陡，有少許路燈不算太陰暗，爬山路程大概 30 分鐘可抵達拍照點。</p><h3 id="登山口"><a href="#登山口" class="headerlink" title="登山口"></a>登山口</h3><hr><p>圓山風景區入口：<a href="https://maps.app.goo.gl/AGCeEeXazAMwf5MP7">25.08077, 121.52450</a><br>街景：<a href="https://maps.app.goo.gl/XqKF8orjT9xeJcQK6">https://maps.app.goo.gl/XqKF8orjT9xeJcQK6</a></p><h3 id="攝影點"><a href="#攝影點" class="headerlink" title="攝影點"></a>攝影點</h3><hr><p>座標：<a href="https://maps.app.goo.gl/sXeWerCvsuGaRcyMA">25.08410, 121.52846</a><br>街景：無</p><h3 id="搭車點"><a href="#搭車點" class="headerlink" title="搭車點"></a>搭車點</h3><hr><p>劍潭捷運站：<a href="https://maps.app.goo.gl/ewCbD3BvhosCDvrG7">25.08427, 121.52497</a><br>街景：<a href="https://maps.app.goo.gl/3XiB8XFLfiSHzwnAA">https://maps.app.goo.gl/3XiB8XFLfiSHzwnAA</a></p><h3 id="停車點"><a href="#停車點" class="headerlink" title="停車點"></a>停車點</h3><hr><p>台北捷運劍潭站轉乘停車場：<a href="https://maps.app.goo.gl/9PfoKJDwuex1VvKGA">25.08276, 121.52493</a><br>街景：<a href="https://maps.app.goo.gl/U1mQ9Wx9s33bkCgZ6">https://maps.app.goo.gl/U1mQ9Wx9s33bkCgZ6</a></p><p>機車路邊停車：<a href="https://maps.app.goo.gl/w44bzroWhCtUAf4g7">25.08007, 121.52445</a><br>街景：<a href="https://maps.app.goo.gl/e7k4M7XzPmRRbK26A">https://maps.app.goo.gl/e7k4M7XzPmRRbK26A</a></p>]]></content>
    
    
    <summary type="html">&lt;a class=&quot;travel-image-link&quot; href=&quot;https://chris81051.github.io/2023/10/29/Travel-Taipei-Zhongshan-night-view-Breeze-platform&quot; target=&quot;_self&quot;&gt;
  &lt;img src=&quot;https://i.imgur.com/53wozHT.jpg&quot; title=&quot;微風平台&quot; width=&quot;85%&quot; high=&quot;85%&quot;&gt;
&lt;/a&gt;</summary>
    
    
    
    <category term="台北" scheme="https://chris81051.github.io/categories/%E5%8F%B0%E5%8C%97/"/>
    
    <category term="中山" scheme="https://chris81051.github.io/categories/%E5%8F%B0%E5%8C%97/%E4%B8%AD%E5%B1%B1/"/>
    
    
    <category term="山區" scheme="https://chris81051.github.io/tags/%E5%B1%B1%E5%8D%80/"/>
    
    <category term="夜景" scheme="https://chris81051.github.io/tags/%E5%A4%9C%E6%99%AF/"/>
    
    <category term="約會" scheme="https://chris81051.github.io/tags/%E7%B4%84%E6%9C%83/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 238. Product of Array Except Self</title>
    <link href="https://chris81051.github.io/2023/10/28/LeetCode-238-Product-of-Array-Except-Self-Java-Python/"/>
    <id>https://chris81051.github.io/2023/10/28/LeetCode-238-Product-of-Array-Except-Self-Java-Python/</id>
    <published>2023-10-28T14:05:28.000Z</published>
    <updated>2023-10-28T14:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題有點類似 Prefix Sums 的概念，目標是找到陣列中元素自己以外的所有元素的乘績，放在一個新的陣列裡，雖然有三個迴圈是 <code>O(3n)</code> 的時間複雜度，但常數項通常會被省略，因此該演算法可達 <code>O(n)</code> 的時間複雜度，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.<br>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p></blockquote><blockquote><p>給定一個整數陣列 <code>nums</code>，回傳一個陣列 <code>answer</code> ，其中 <code>answer[i]</code> 等於所有元素的乘積，除了 <code>nums[i]</code><br>保證 <code>nums</code> 陣列中任何的前後綴都適合 <strong>32-bit</strong> 的整數<br>你必須寫出一個時間複雜度為 <code>O(n)</code> 的算法且不能使用除法</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/product-of-array-except-self/">https://leetcode.com/problems/product-of-array-except-self/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>2 &lt;= nums.length &lt;= 105</code><br><code>30 &lt;= nums[i] &lt;= 30</code></p><p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Output: [<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>nums [0] ⇒ 把 2、3、4 都乘起來<br>nums [1] ⇒ 把 1、3、4 都乘起來<br>(以此類推)<br>把全部乘完的元素都放在 <code>answer</code> 裡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">Output: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>nums [0] ⇒ 把 1、0、-3、3 都乘起來<br>nums [1] ⇒ 把 -1、0、-3、3 都乘起來<br>(以此類推)<br>把全部乘完的元素都放在 <code>answer</code> 裡</p><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><blockquote><ul><li>簡而言之我們要把除了 <code>nums[i]</code> 以外的元素乘起來，並且對每一個 <code>i</code> 做一樣的事情</li><li>然後每個索引之前之後的元素都要相乘，就是 <code>自己前面的乘積</code> * <code>自己後面的乘積</code></li></ul></blockquote><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">// 前綴乘積</span></span><br><span class="line">        <span class="type">int</span> right[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">// 後綴乘積</span></span><br><span class="line">        <span class="type">int</span> answer[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 第一個元素設為 1</span></span><br><span class="line">        right[nums.length-<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 陣列最後一個元素設為 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            left[i] = nums[i - <span class="number">1</span>] * left[i - <span class="number">1</span>]; <span class="comment">// left = [1, 1, 2, 6]</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計數器 i 從陣列後面遞減回來</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            right[i] = nums[i + <span class="number">1</span>] * right[i + <span class="number">1</span>]; <span class="comment">// right = [24, 12, 4, 1]</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把兩個陣列的成績相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            answer[i] = left[i] * right[i];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        left, right, answer = [<span class="number">0</span>] * <span class="built_in">len</span>(nums), [<span class="number">0</span>] * <span class="built_in">len</span>(nums), [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 第一個元素設為 1</span></span><br><span class="line">        right[<span class="built_in">len</span>(nums)-<span class="number">1</span>] = <span class="number">1</span> <span class="comment"># 陣列最後一個元素設為 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            left[i] = nums[i-<span class="number">1</span>] * left[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 計數器 i 從陣列後面遞減回來</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            right[i] = nums[i+<span class="number">1</span>] * right[i+<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把兩個陣列的成績相乘</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            answer[i] = left[i] * right[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>2ms</td><td>53.43MB</td></tr><tr><td>Python</td><td>202ms</td><td>25.48MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題有點類似 Prefix Sums 的概念，找到陣列中元素自己以外的所有元素的乘績</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 560. Subarray Sum Equals K</title>
    <link href="https://chris81051.github.io/2023/10/09/LeetCode-560-Subarray-Sum-Equals-K-Java-Python/"/>
    <id>https://chris81051.github.io/2023/10/09/LeetCode-560-Subarray-Sum-Equals-K-Java-Python/</id>
    <published>2023-10-09T09:38:22.000Z</published>
    <updated>2023-10-09T09:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題學習目標是 Prefix Sums 前綴和的概念， Prefix Sums 通常用於需要頻繁查詢陣列中某一區間的元素和的情況，這裡目標是找到一個陣列中連續子陣列的合回傳最大值，時間複雜度估為 <code>O(n^2)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of subarrays whose sum equals to</em> <code>k</code>.<br>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p></blockquote><blockquote><p>給定一個整數陣列 <code>nums</code> 和一個整數 <code>k</code>，回傳總合等於 k 值的連續子陣列的數量。<br>子陣列是陣列中連續的非空元素陣列。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/subarray-sum-equals-k/">https://leetcode.com/problems/subarray-sum-equals-k/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= nums.length &lt;= 2 * 104</code><br><code>1000 &lt;= nums[i] &lt;= 1000</code><br><code>107 &lt;= k &lt;= 107</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>[1, 1] ⇒ 2 ，符合 k 值的大小<br>[1, 1] ⇒ 2 ，符合 k 值的大小<br>所以 nums 陣列可以有兩個子陣列，Output 回傳 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>[1, 2] ⇒ 3 ，符合 k 值的大小<br>[3] ⇒ 3 ，符合 k 值的大小<br>所以 nums 陣列可以有兩個子陣列，Output 回傳 2</p><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>這題主要的思路是 Prefix Sums 為某一個區間和的算法</p><blockquote><ul><li>我們先把符合 nums 陣列其中一個連續子陣列，拿出來做說明回推</li><li>假如有一連續子陣列 prefix_sum &#x3D; [2, 2, 3]</li><li>然後把這個子陣列的前綴和的終點 - 前綴和的起點，終點就是 3 ，起點就是 2</li><li>這裡概念上不是數學上的減去，而是空間上的減去</li><li>如果獲取的子陣列 prefix_sum 的前綴和相減等於 k 的話 count++</li></ul></blockquote><p>筆者用示意圖可能會比較清晰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for example</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">k = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">prefix_sum = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>] = <span class="number">7</span></span><br><span class="line">prefix_sum_end = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>] = <span class="number">11</span></span><br><span class="line">prefix_sum_start = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">prefix_sum_end - sum_prefix_start =&gt; [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>] - [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">prefix_sum = k 成立，count++</span><br></pre></td></tr></table></figure><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>]; <span class="comment">// 設定前綴和的陣列</span></span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 設定陣列第一個索引為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把陣列中所有的元素加起來，組合成各個前綴和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++)</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]; <span class="comment">// sum = [0, 1, 1+2, 1+2+3]</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; sum.length; start++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + <span class="number">1</span>; end &lt; sum.length; end++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[end] - sum[start] == k) <span class="comment">// 前綴和的終點 - 前綴和的起點</span></span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法，不過超過了時間限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)+<span class="number">1</span>) <span class="comment"># 設定前綴和的陣列</span></span><br><span class="line">        <span class="built_in">sum</span>[<span class="number">0</span>] = <span class="number">0</span> <span class="comment"># 設定陣列第一個索引為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把陣列中所有的元素加起來，組合成各個前綴和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="built_in">sum</span>[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>] <span class="comment"># sum = [0, 1, 1+2, 1+2+3]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">sum</span>)):</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start+<span class="number">1</span>, <span class="built_in">len</span>(<span class="built_in">sum</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>[end] - <span class="built_in">sum</span>[start] == k: <span class="comment"># 前綴和的終點 - 前綴和的起點</span></span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>另一種寫法加入 python 的字典來演算，作用是幫助我們統計前綴和出現的次數</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span> </span><br><span class="line">        prefix_sum = <span class="number">0</span> <span class="comment"># 當前的前綴和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 字典 d 的 key 是前綴和，value 是該前綴和出現的次數</span></span><br><span class="line">        d = &#123;<span class="number">0</span> : <span class="number">1</span>&#125; <span class="comment"># 初始將 0 的出現次數設為 1，表示前綴和為 0 的情況</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line"></span><br><span class="line">            prefix_sum = prefix_sum + num <span class="comment"># 更新當前的前綴和</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 因為已經設定為 0 ，說明存在一個前綴和相減為 0 ，代表和 k 一樣</span></span><br><span class="line">            <span class="keyword">if</span> prefix_sum - k <span class="keyword">in</span> d:</span><br><span class="line">                count = count + d[prefix_sum - k] <span class="comment"># count 次數：0 + 1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果不存在，表示這是首次遇到這個前綴和，將該前綴和作為 key，將其出現次數設為 1。</span></span><br><span class="line">            <span class="keyword">if</span> prefix_sum <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[prefix_sum] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[prefix_sum] = d[prefix_sum] + <span class="number">1</span> <span class="comment"># 代表已經有其他前綴和等於當前的前綴和，把相同的前綴和 + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>1556ms</td><td>44.65MB</td></tr><tr><td>Python</td><td>264ms</td><td>18.91MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題學習目標是 Prefix Sums 前綴和的概念</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Hash Table" scheme="https://chris81051.github.io/tags/Hash-Table/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 287. Find the Duplicate Number</title>
    <link href="https://chris81051.github.io/2023/09/10/LeetCode-287-Find-the-Duplicate-Number-Java-Python/"/>
    <id>https://chris81051.github.io/2023/09/10/LeetCode-287-Find-the-Duplicate-Number-Java-Python/</id>
    <published>2023-09-10T15:35:30.000Z</published>
    <updated>2023-09-10T15:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題是一題把陣列當成類似 linked list 的題目，目標是找到陣列中重複的元素，因它只對陣列進行了兩次循環，而每次循環都是線性時間的運作，時間複雜度可達 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.<br>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.<br>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p></blockquote><blockquote><p>給定一個整數陣列 <code>nums</code> 含有 <code>n + 1</code> 個整數，每個整數都在 <code>[1, n]</code> 範圍包含裡。<br><code>nums</code>  中只有一個重複的數字，回傳這個重複的數字。<br>你必須在不能修改 <code>nums</code> 的情況下解決這個問題，而且只能使用常數的記憶體空間。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/find-the-duplicate-number/">https://leetcode.com/problems/find-the-duplicate-number/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= n &lt;= 105</code><br><code>nums.length == n + 1</code><br><code>1 &lt;= nums[i] &lt;= n</code></p><p>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>暴力的解法是利用雙迴圈，找出相等的元素後就是答案，結果超過時間限制 (不採用)</p><p>另一種解法，運用 HashSet 方法的特性，找出不能出現的元素</p><blockquote><ul><li>循環 nums 陣列，把每個元素添加到 HashSet 中</li><li>如果發現某個元素已經存在於 HashSet 中，那麼這個元素就是重複的</li><li>回傳這個元素</li></ul></blockquote><p>第三種解法是使用鏈表的特性，在鏈表內的元素不會有重複，有重複的話會形成一個環</p><blockquote><ul><li>把當前的元素，當成下一個元素的 index，變成一個類似 linked list 的鏈表</li><li>然後設定一組快慢指針，慢指針走一步，快指針走兩步，在鏈表中有重複的元素，快指針會先走到有重複元素的環內，慢指針也會走到有重複元素的環內，這時如果快慢指針都走到相同的元素，代表這個元素就是我們要找的重複的元素</li><li>例如走過 2 這個元素，後面又再次遇到 2 的時候，代表 2 是重複的元素，然而會形成一個環，在這個有重複元素的還內一直打轉</li><li>另外設定第三個指針檢查，用意是找出環的頭，無論用慢指針或快指針去和檢查指針比對都行，快慢指針是一樣的元素</li></ul></blockquote><div style="display:inline-block;">     <img width="50%" src="https://i.imgur.com/LYhEQC6.png" alt="" style="float: left; margin-right: 10px;"> </div><p>while 迴圈從 0 開始走，到 3 的時候已經遇到一個 2 了，繼續走到 4 的時候又遇到一個 2</p><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力的解法是利用雙迴圈，找出相等的元素後就是答案，結果超過時間限制 (不採用)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一種解法，運用 HashSet 方法的特性，找出不能出現的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 添加進去時會判斷有沒有 (重複元素不會被添加)</span></span><br><span class="line">            <span class="keyword">if</span>(!set.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num; <span class="comment">// 回傳當下這個元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三種解法是使用鏈表的特性，在鏈表內的元素不會有重複，有重複的話會形成一個環</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 慢指針</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 快指針</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">check</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 確認指針</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>( <span class="literal">true</span> )&#123;</span><br><span class="line">            slow = nums[slow]; <span class="comment">// 取得 index 位置(走一步)</span></span><br><span class="line">            fast = nums[nums[fast]]; <span class="comment">// 取得 index 位置後，從位置再取一次新的位置 (等於走兩步)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果快慢指針一樣</span></span><br><span class="line">            <span class="keyword">if</span>( slow == fast )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找出循環的頭</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="literal">true</span> )&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            check = nums[check]; <span class="comment">// 檢查指針</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果慢指針和檢查指針一樣</span></span><br><span class="line">            <span class="keyword">if</span>( slow == check )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> check;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        check = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            slow = nums[slow] <span class="comment"># 取得 index 位置(走一步)</span></span><br><span class="line">            fast = nums[nums[fast]] <span class="comment"># 取得 index 位置後，從位置再取一次新的位置 (等於走兩步)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果快慢指針一樣</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找出循環的頭</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            check = nums[check]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果慢指針和檢查指針一樣</span></span><br><span class="line">            <span class="keyword">if</span> slow == check:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>4ms</td><td>59.49MB</td></tr><tr><td>Python</td><td>520ms</td><td>30.95MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題是一題把陣列當成類似 linked list 的題目，目標是找到陣列中重複的元素</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 56. Merge Intervals</title>
    <link href="https://chris81051.github.io/2023/08/27/LeetCode-56-Merge-Intervals-Java-Python/"/>
    <id>https://chris81051.github.io/2023/08/27/LeetCode-56-Merge-Intervals-Java-Python/</id>
    <published>2023-08-27T07:01:22.000Z</published>
    <updated>2023-08-27T07:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題運用雙指針來實作，目標是把陣列中的元素重疊的部分合併起來，有使用到合併和排序的演算法，時間複雜度估為 <code>O(n log n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p></blockquote><blockquote><p>給定一個陣列 <code>intervals</code> 其中，間隔在 <code>intervals[i] = [starti, endi]</code>，合併全部有重疊的間隔，並回傳覆蓋輸入中所有區間的非重疊區間的陣列。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/merge-intervals/">https://leetcode.com/problems/merge-intervals/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= intervals.length &lt;= 104</code><br><code>intervals[i].length == 2</code><br><code>0 &lt;= starti &lt;= endi &lt;= 104</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Explanation: Since intervals [<span class="number">1</span>,<span class="number">3</span>] and [<span class="number">2</span>,<span class="number">6</span>] overlap, merge them into [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p>區間 [ 1, 3 ] 和 [ 2, 6 ] 重疊，將它們合併為 [ 1, 6 ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">Explanation: Intervals [<span class="number">1</span>,<span class="number">4</span>] and [<span class="number">4</span>,<span class="number">5</span>] are considered overlapping.</span><br></pre></td></tr></table></figure><p>區間 [ 1, 4 ] 和 [ 4, 5 ] 可被視為重疊區間</p><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><blockquote><ul><li>將原始的陣列做升序排序</li><li>宣告一個 res (來裝判斷過的元素)</li><li>把 intervals 的第一個元素裝入 res</li><li>for 迴圈從 intervals 第二個元素開始循環</li><li>如果 res 最後一個元素後面的值 ≥ intervals 第二個元素前面的值的話</li><li>將 intervals 第二個元素後面的值比較 res 最後一個元素後面的值，取較大的值合併</li></ul></blockquote><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 初始化陣列 (因為不知道陣列元素有幾個)</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>])); <span class="comment">// 把陣列排成升序</span></span><br><span class="line">        res.add(intervals[<span class="number">0</span>]); <span class="comment">// 添加陣列第一個區間 res = [[1,3]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原本的陣列從第二個開始循環比較</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; intervals.lenght - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果有重疊的話</span></span><br><span class="line">            <span class="keyword">if</span> (res.get(res.size() - <span class="number">1</span>)[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                res.get(res.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(res.get(res.size() - <span class="number">1</span>)[<span class="number">1</span>], intervals[i][<span class="number">1</span>]); <span class="comment">// 取較大的值合併</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(intervals[i]); <span class="comment">// 沒有重疊，直接加入結果列表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]); <span class="comment">// 沒有重疊，轉成陣列輸出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        intervals.sort()  <span class="comment"># 對區間列表進行排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 準備一個容器來裝合併的元素 (索引 0 先放進去)</span></span><br><span class="line">        res = [intervals[<span class="number">0</span>]]  <span class="comment"># 添加陣列第一個區間 res = [[1,3]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原本的陣列從第二個開始循環比較</span></span><br><span class="line">        <span class="comment"># intervals[1:]</span></span><br><span class="line">        <span class="comment"># Iteration 1: start = 2, end = 6</span></span><br><span class="line">        <span class="comment"># Iteration 2: start = 8, end = 10</span></span><br><span class="line">        <span class="comment"># Iteration 3: start = 15, end = 18</span></span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 如果有重疊</span></span><br><span class="line">            <span class="keyword">if</span> res[-<span class="number">1</span>][<span class="number">1</span>] &gt;= start:</span><br><span class="line">                res[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(res[-<span class="number">1</span>][<span class="number">1</span>], end)  <span class="comment"># 取較大的值合併</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([start, end])  <span class="comment"># 沒有重疊，直接加入結果列表</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>7ms</td><td>45.34MB</td></tr><tr><td>Python</td><td>130ms</td><td>21.40MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題運用雙指針來實作，目標是把陣列中的元素重疊的部分合併起來</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Recursion" scheme="https://chris81051.github.io/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 200. Number of Islands</title>
    <link href="https://chris81051.github.io/2023/08/08/LeetCode-200-Number-of-Islands-Java-Python/"/>
    <id>https://chris81051.github.io/2023/08/08/LeetCode-200-Number-of-Islands-Java-Python/</id>
    <published>2023-08-08T15:22:33.000Z</published>
    <updated>2023-08-08T15:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題是一個經典的 DFS 深度優先搜尋問題，聽說是 FAANG 高頻題(?，目標是在二維陣列裡找到連續出現 1 的範圍 (島嶼)，計算島嶼共出現幾個，這題有使用到兩個 for 迴圈加上遞迴，如果遞迴深度是固定的且不隨著輸入的增加而增加，而遞迴的深度和節點訪問僅發生一次，則遞迴的時間複雜度可以被忽略，時間複雜度估算為 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.<br>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p></blockquote><blockquote><p>給定一個 <code>m x n</code> 的 2D 二進制網格 <code>grid</code> ，他代表 <code>&#39;1&#39;</code> 是陸地 <code>&#39;0&#39;</code> 是水的一張地圖，回傳這座島的數量。<br>一座島被水包圍，通過水平或垂直連結鄰近的土地而形成。你可以認為網格的全部四個邊都被水包圍。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/number-of-islands/">https://leetcode.com/problems/number-of-islands/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>m == grid.length</code><br><code>n == grid[i].length</code><br><code>1 &lt;= m, n &lt;= 300</code><br><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>左上角 9 個 1 連續在一起，共 1 座島嶼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>左上角 4 個 1、中間 1 個 1、右下角 2 個 1，共 3 座島嶼</p><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>快速地說是用雙迴圈找到了第一個 1，之後用 DFS 深度優先搜尋找他周圍是不是也是 1，然後當次的 DFS 完整跑完代表這個 Islands 的周圍全都是 0 了，可以用雙迴圈繼續找尋下一個 1 的位置 (第二個 Islands)</p><blockquote><ul><li>用雙迴圈依依找尋是 Islands 的索引 (是 1 的元素)</li><li>找到 Islands 後執行 DFS 深度優先搜尋，去找位於這個 Islands 索引的上下左右的索引是不是也是 1 (連續是 1 代表是同一個 Islands )</li><li>如果上下左右的索引不是 1 的話，而且自己也不是 1的話直接 return 出去，終止這次的 DFS</li><li>如果是 1 的話就換成 0，避免之後重複計算</li><li>執行完當次的 DFS，代表這個 Islands 上下左右都是 0，計算了這個 Islands 的數量後</li><li>直到雙迴圈再找到下一個 1 才會進去算到第二個 Islands (以此類推)</li></ul></blockquote><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 計算 Islands 的數量</span></span><br><span class="line">        <span class="keyword">if</span> (grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果沒答案回傳 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) <span class="comment">// 因為每個二維陣列的長度一樣</span></span><br><span class="line">                <span class="comment">// 如果是 &#x27;1&#x27; 就是 Islands</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    DFS(grid, i, j); <span class="comment">// 使用深度優先搜尋後</span></span><br><span class="line">                    count++; <span class="comment">// 當下的 DFS 完全找完後記得 Islands 數量要加</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i &lt; 0：表示越過了二維陣列的上方邊界。</span></span><br><span class="line">    <span class="comment">// j &lt; 0：表示越過了二維陣列的左方邊界。</span></span><br><span class="line">    <span class="comment">// i &gt;= grid.length：表示越過了二維陣列的下方邊界。</span></span><br><span class="line">    <span class="comment">// j &gt;= grid[0].length：表示越過了二維陣列的右方邊界。</span></span><br><span class="line">    <span class="comment">// grid[i][j] != &#x27;1&#x27;：表示遍歷的點不是陸地（可能是水，或者已經被訪問過的陸地）。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上下左右是 0 的話不做任何事 (停止的意思)，確保我們只對合法的陸地格子執行 DFS 遞迴搜索</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 把遍歷到的陸地 1 換成 0，避免重複計算成 Islands</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遞迴</span></span><br><span class="line">        DFS(grid, i + <span class="number">1</span>, j); <span class="comment">// 找尋四個方向的下方</span></span><br><span class="line">        DFS(grid, i - <span class="number">1</span>, j); <span class="comment">// 找尋四個方向的上方</span></span><br><span class="line">        DFS(grid, i, j + <span class="number">1</span>); <span class="comment">// 找尋四個方向的右方</span></span><br><span class="line">        DFS(grid, i, j - <span class="number">1</span>); <span class="comment">// 找尋四個方向的左方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果沒答案回傳 0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 計算 Islads 數量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># 如果是島嶼的話</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    self.DFS(grid, i, j) <span class="comment"># 使用 DFS 深度優先搜尋</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 索引：上邊界、下邊界、左邊界、右邊界、自己，上下左右是 0 的話不做任何事 (停止的意思)</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> i&gt;=<span class="built_in">len</span>(grid) <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment"># 設置為 0，避免重複計算</span></span><br><span class="line">        </span><br><span class="line">        self.DFS(grid, i-<span class="number">1</span>, j) <span class="comment"># 上</span></span><br><span class="line">        self.DFS(grid, i+<span class="number">1</span>, j) <span class="comment"># 下</span></span><br><span class="line">        self.DFS(grid, i, j-<span class="number">1</span>) <span class="comment"># 左</span></span><br><span class="line">        self.DFS(grid, i, j+<span class="number">1</span>) <span class="comment"># 右</span></span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>3ms</td><td>47.3MB</td></tr><tr><td>Python</td><td>274ms</td><td>18.9MB</td></tr></tbody></table><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><hr><p>DFS 深度優先搜尋：<a href="https://www.youtube.com/watch?v=U3IpByPjKtU&amp;t=1s">https://www.youtube.com/watch?v=U3IpByPjKtU&amp;t=1s</a></p>]]></content>
    
    
    <summary type="html">這題是一個經典的 DFS 深度優先搜尋問題，聽說是 FAANG 高頻題(?</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="DFS" scheme="https://chris81051.github.io/tags/DFS/"/>
    
    <category term="Recursion" scheme="https://chris81051.github.io/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 33. Search in Rotated Sorted Array</title>
    <link href="https://chris81051.github.io/2023/08/01/LeetCode-33-Search-in-Rotated-Sorted-Array-Java-Python/"/>
    <id>https://chris81051.github.io/2023/08/01/LeetCode-33-Search-in-Rotated-Sorted-Array-Java-Python/</id>
    <published>2023-08-01T14:23:00.000Z</published>
    <updated>2023-08-01T14:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題主要運用到二分搜尋法，是 704. Binary Search 的變化題，目標是找到一個旋轉陣列中指定元素的陣列，用到一個 while 迴圈和其餘 if 判斷，時間複雜度估 <code>O(log n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).<br>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.<br>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.<br>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p></blockquote><blockquote><p>有一個整數陣列 <code>nums</code> 已升序排序 (且具不同的值)。<br>在傳遞給你的函數之前，<code>nums</code> 可能在一個未知的樞軸索引 <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) 處旋轉，這樣得到的陣列是 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>索引從0開始</strong>)，例如，<code>[0,1,2,4,5,6,7]</code> 可能會在樞軸 3 處旋轉並變成 <code>[4,5,6,7,0,1,2]</code> 。<br>給定一個可能的旋轉後的陣列 <code>nums</code> 和一個整數 <code>target</code>，如果 <code>target</code> 它在 <code>nums</code> 中就回傳 <code>target</code> 的索引， 如果它不在 <code>nums</code> 中就回傳 <code>-1</code>。<br>你必須寫出一個 <code>O(log n)</code> 時間複雜度的演算法。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= nums.length &lt;= 5000</code><br><code>104 &lt;= nums[i] &lt;= 104</code><br>All values of <code>nums</code> are <strong>unique</strong>.<br><code>nums</code> is an ascending array that is possibly rotated.<br><code>104 &lt;= target &lt;= 104</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">Output: -<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], target = <span class="number">0</span></span><br><span class="line">Output: -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>這題用的技巧是二分搜尋法，原理是每次循環都會將陣列搜索範圍縮小一半，目的是要找到 target 值的 index</p><blockquote><ul><li>初始我們會設定起點位置、終點位置、中間點 (這些是二分搜尋法的必要條件)</li><li><code>middle = start + ( end - start ) / 2</code> 可取得中間點</li><li>如果整個陣列都是有序的，那麼目標整數 target 必然存在於該有序的部分，我們可以直接進行二分搜尋找到目標值，但這題比較麻煩的是我們不知道陣列會旋轉成什麼樣子，所以先判斷陣列的左邊還是右邊是否有序</li><li>如果那半邊是有序的，就在那半邊使用二分搜尋法做搜尋</li><li>如果 target 不在那半邊的話，則會轉向另一邊做搜尋</li><li>直到 start 大於等於 end，表示搜尋範圍為空，結束搜尋</li><li>到最後範圍會縮到最小，起點值和目標值一定會重疊，然後回傳答案索引</li></ul></blockquote><p>[注意點] 之所以要用上述中間點的寫法會比較安全，因如果 start 和 end 趨近於最大數時，兩者相加起來的合可能會造成整數溢位</p><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 起點位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 終點位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> start + (end-start)/<span class="number">2</span>; <span class="comment">// 中間點</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] == target) <span class="keyword">return</span> middle; <span class="comment">// 剛好中間點就是答案就回傳</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷左半邊是有序的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt;= nums[middle]) &#123;</span><br><span class="line">                <span class="comment">// 如果 target 在左半邊的範圍內，則繼續在左半邊進行搜尋</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[middle]) &#123;</span><br><span class="line">                    <span class="comment">// 重新定義終點，下次回圈找到新的終點就好</span></span><br><span class="line">                    end = middle - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 否則，轉向右半邊進行搜尋</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 重新定義起點，下次回圈從新的起點開始就好</span></span><br><span class="line">                    start = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 否則，右半邊是有序的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[middle] &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">                    start = middle + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到最後範圍會縮到最小，起點值和目標值一定會重疊，就回傳索引</span></span><br><span class="line">        <span class="keyword">return</span> nums[start] == target ? start : -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法<br>不一樣的點是變數的宣告方式不一樣，還有 Java 和 Python 的三元運算寫法不一樣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        start, end  = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="comment"># 起點、終點</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            middle = start + (end - start) // <span class="number">2</span> <span class="comment"># 中間點</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 中間點是答案就回傳</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] == target </span><br><span class="line">                <span class="keyword">return</span> middle </span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判斷左半邊是有序的</span></span><br><span class="line">                <span class="keyword">if</span> nums[start] &lt;= nums[middle]:</span><br><span class="line">                    <span class="comment"># 如果 target 在左半邊的範圍內，則繼續在左半邊進行搜尋</span></span><br><span class="line">                    <span class="keyword">if</span> nums[start] &lt;= target <span class="keyword">and</span> target &lt; nums[middle]:</span><br><span class="line">                    end = middle - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    start = middle + <span class="number">1</span> <span class="comment"># 否則，轉向右半邊進行搜尋</span></span><br><span class="line">            <span class="comment"># 否則，右半邊是有序的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[middle] &lt; target <span class="keyword">and</span> target &lt;= nums[end]:</span><br><span class="line">                    start = middle + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = middle - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果 start == target 回傳 start 否則回傳 -1</span></span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> nums[start] == target <span class="keyword">else</span> -<span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>0ms</td><td>41.2MB</td></tr><tr><td>Python</td><td>54ms</td><td>16.75MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題主要運用到二分搜尋法，是 704. Binary Search 的變化題</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Hash Table" scheme="https://chris81051.github.io/tags/Hash-Table/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 215. Kth Largest Element in an Array</title>
    <link href="https://chris81051.github.io/2023/07/23/LeetCode-215-Kth-Largest-Element-in-an-Array-Java-Python/"/>
    <id>https://chris81051.github.io/2023/07/23/LeetCode-215-Kth-Largest-Element-in-an-Array-Java-Python/</id>
    <published>2023-07-23T08:53:37.000Z</published>
    <updated>2023-07-23T08:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　解這題最重要的是學習 Quick Sort 快速排序演算法是如何運作的，實作中間也可學到遞迴的概念，題目目標是把陣列從小到大排序後，找到給定的元素大小位置就是答案，在每次遞歸中我們需要線性的時間 <code>O(n)</code> 來進行分區操作。快速排序的遞歸樹的深度為 <code>O(log n)</code>，時間複雜度估算為 <code>O(n log n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.<br>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.<br>Can you solve it without sorting?</p></blockquote><blockquote><p>給定一個整數陣列 <code>nums</code> 和一個整數 <code>k</code>，回傳在這個陣列裡第 <code>k</code> 個最大的元素<br>注意它是排序順序中第 <code>k</code> 個最大的元素，不是第 <code>k</code> 個不同的元素<br>你能不排序解決它嗎?</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= k &lt;= nums.length &lt;= 105</code><br><code>104 &lt;= nums[i] &lt;= 104</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>], k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>解這題之前可能要先去了解一下 Quick Sort 快速排序演算法的原理，來作這題會比較好懂<br>不過也是可以使用語言自帶的 <code>sort()</code> 方法來排序完，之後再把 k 個索引減掉就是答案了<br>另外這題也有運用到遞迴的概念，可能也要稍微去了解一下<br>這題總共會寫到三個 function，第一個 <code>quickSort()</code> 來執行遞迴，第二個 <code>partition()</code> 來執行把陣列排序後找到某個元素最正確的位置，第三個 <code>swap()</code> 來執行元素和元素間的交換</p><blockquote><ul><li>原本的 function 來呼叫自己寫的 <code>quickSort()</code> ，把陣列元素從小排到大，之後陣列的長度減掉 k 個索引就是我們要的答案</li><li>執行 <code>quickSort()</code> ，呼叫第一次 <code>partition()</code> 方法會取得 pivot 的最正確的位置 ( pivot 作為中心點用於分辨左右兩邊的元素)</li><li>之後利用遞迴重複做 <code>partition()</code> 方法裡面的事情，<code>partition()</code> 方法已經做完一次排序了但還不夠完整，需要靠多次遞迴做一樣的事把小到大排序排到完整，做完第一次會把較小的元素放在 pivot 的左邊，右邊都放較大的元素 ，這裡會呼應上面所講的 pivot 的位置很重要，後續做的遞迴都是依靠這個位置在分辨左右邊的元素 (下方有示意圖可供參考)</li><li>不過做遞迴時傳進去的參數是 <code>quickSort(nums, start, pivot - 1);</code> 和 <code>quickSort(nums, pivot + 1, end);</code>，最後會得出整個陣列以小到大的排序結果</li><li>另外也寫了 <code>swap()</code> 方法，用於交換元素</li></ul></blockquote><p>[備註] <code>pivot - 1</code> 的意思是，<code>partition()</code> 做第一次排序的時候 pivot  最正確的位置已經被找出來了，遞迴在往後做的時候僅只要做左半邊的部分，所以迴圈的結束點會落在 pivot 的前一個索引，右半邊原理相同，起始點從 <code>pivot +1</code> 開始做循環。</p><h3 id="partition-function-示意圖"><a href="#partition-function-示意圖" class="headerlink" title="partition function 示意圖"></a>partition function 示意圖</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列範例 [5, 7, 1, 3, 2, 4]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> end;                     <span class="comment">// pivot 比較的目標數 (指標二)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> start;              <span class="comment">// pivotIndex 最正確的位置 (指標三)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++)&#123;    <span class="comment">// i 迴圈起始 指標一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     i                           pivot</span><br><span class="line">     ↓                             ↓</span><br><span class="line">[    <span class="number">5</span>,    <span class="number">7</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>,    <span class="number">4</span>    ]</span><br><span class="line">     ↑</span><br><span class="line"> pivotIndex</span><br><span class="line"></span><br><span class="line">num[i] &gt; num[pivot] 不做交換</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           i                     pivot</span><br><span class="line">           ↓                       ↓</span><br><span class="line">[    <span class="number">5</span>,    <span class="number">7</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>,    <span class="number">4</span>    ]</span><br><span class="line">     ↑</span><br><span class="line"> pivotIndex</span><br><span class="line"></span><br><span class="line">num[i] &gt; num[pivot] 不做交換</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 i               pivot</span><br><span class="line">                 ↓                 ↓</span><br><span class="line">[    <span class="number">5</span>,    <span class="number">7</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>,    <span class="number">4</span>    ]</span><br><span class="line">     ↑</span><br><span class="line"> pivotIndex</span><br><span class="line"></span><br><span class="line">num[i] &lt; num[pivot]</span><br><span class="line">num[i] 和 num[pivotIndex] 做交換</span><br><span class="line">(<span class="number">1</span> 跑到 <span class="number">5</span> 的位置)</span><br><span class="line">pivotIndex++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                       i         pivot</span><br><span class="line">                       ↓           ↓</span><br><span class="line">[    <span class="number">1</span>,    <span class="number">7</span>,    <span class="number">5</span>,    <span class="number">3</span>,    <span class="number">2</span>,    <span class="number">4</span>    ]</span><br><span class="line">           ↑</span><br><span class="line">       pivotIndex</span><br><span class="line"></span><br><span class="line">num[i] &lt; num[pivot]</span><br><span class="line">num[i] 和 num[pivotIndex] 做交換</span><br><span class="line">(<span class="number">3</span> 跑到 <span class="number">7</span> 的位置)</span><br><span class="line">pivotIndex++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                             i   pivot</span><br><span class="line">                             ↓     ↓</span><br><span class="line">[    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">5</span>,    <span class="number">7</span>,    <span class="number">2</span>,    <span class="number">4</span>    ]</span><br><span class="line">                 ↑</span><br><span class="line">             pivotIndex</span><br><span class="line"></span><br><span class="line">num[i] &lt; num[pivot]</span><br><span class="line">num[i] 和 num[pivotIndex] 做交換</span><br><span class="line">(<span class="number">2</span> 跑到 <span class="number">5</span> 的位置)</span><br><span class="line">pivotIndex++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                i、pivot</span><br><span class="line">                                  ↓↓</span><br><span class="line">[    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>,    <span class="number">7</span>,    <span class="number">5</span>,    <span class="number">4</span>    ]</span><br><span class="line">                       ↑</span><br><span class="line">                   <span class="type">pivotIndex</span></span><br><span class="line"></span><br><span class="line"><span class="variable">i</span> <span class="operator">=</span> end 所以 <span class="keyword">for</span> 迴圈停止</span><br><span class="line">pivotIndex 和 i 做交換</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>,    <span class="number">4</span>,    <span class="number">5</span>,    <span class="number">7</span>    ]</span><br><span class="line">                       ↑</span><br><span class="line">                   pivotIndex</span><br><span class="line">陣列已排序了第一次</span><br><span class="line">把 pivotIndex 回傳出去</span><br></pre></td></tr></table></figure><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k]; <span class="comment">// 已排序後的陣列(小到大)，減掉 k 個索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">// 從陣列的第一個元素做到倒數第二個元素</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums, start, end); <span class="comment">// 找出最正確的位置</span></span><br><span class="line">            <span class="comment">// 做遞迴</span></span><br><span class="line">            <span class="comment">// pivot-1 代表循環左半邊元素時，start 指標從索引 0 開始循環，循環到 pivot 前一個索引結束</span></span><br><span class="line">            <span class="comment">// pivot+1 代表循環右半邊元素時， start 指標從 pivot 的後面一個索引開始循環，到最後一個索引結束</span></span><br><span class="line">            quickSort(nums, start, pivot - <span class="number">1</span>); </span><br><span class="line">            quickSort(nums, pivot + <span class="number">1</span>, end); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先執行一次，把最後一個元素放到最正確的位置上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> end; <span class="comment">// 陣列裡最後一個索引 (指標二)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> start; <span class="comment">// 陣列裡第一個索引 (指標三)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i (指標一)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="comment">// 開始從前面遍歷陣列，把每個元素和最後一個元素比較</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[pivot])&#123;</span><br><span class="line">                swap(nums, i, pivotIndex); <span class="comment">// 指標一、指標三做交換</span></span><br><span class="line">                pivotIndex++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素全部做完，最後要把 pivot 放到最正確的位置上</span></span><br><span class="line">        swap(nums, pivotIndex, pivot);</span><br><span class="line">        <span class="keyword">return</span> pivotIndex; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交換函數</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums) - k]  <span class="comment"># 已排序後的陣列(大到小)，取倒數第 k 個元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], start:<span class="built_in">int</span>, end:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> start &lt; end:</span><br><span class="line">            pivot = self.partition(nums, start, end)  <span class="comment"># 第一次排序得到 pivot 最正確的位置</span></span><br><span class="line">            self.quickSort(nums, start, pivot - <span class="number">1</span>)  <span class="comment"># 處理左邊</span></span><br><span class="line">            self.quickSort(nums, pivot + <span class="number">1</span>, end)  <span class="comment"># 處理右邊</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], start:<span class="built_in">int</span>, end:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        pivot = end  <span class="comment"># 指標二</span></span><br><span class="line">        pivotIndex = start  <span class="comment"># 指標三</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># i 為指標一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">            <span class="comment"># 把每個元素和最後一個元素比較</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[pivot]:</span><br><span class="line">                self.swap(nums, i, pivotIndex)  <span class="comment"># 交換</span></span><br><span class="line">                pivotIndex += <span class="number">1</span></span><br><span class="line">        self.swap(nums, pivot, pivotIndex)  <span class="comment"># 把 pivot 放到最正確的位置上</span></span><br><span class="line">        <span class="keyword">return</span> pivotIndex</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 交換函數</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i:<span class="built_in">int</span>, j:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        temp = nums[i]</span><br><span class="line">        nums[i] = nums[j]</span><br><span class="line">        nums[j] = temp</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>138ms</td><td>54.27MB</td></tr><tr><td>Python</td><td>9610ms</td><td>32.34MB</td></tr></tbody></table><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><hr><p>Quick Sort 快速排序：<a href="https://www.youtube.com/watch?v=mrW5OSr3OVc">https://www.youtube.com/watch?v=mrW5OSr3OVc</a></p>]]></content>
    
    
    <summary type="html">解這題最重要的是學習 Quick Sort 快速排序演算法是如何運作</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Recursion" scheme="https://chris81051.github.io/tags/Recursion/"/>
    
    <category term="QuickSort" scheme="https://chris81051.github.io/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 206. Reverse Linked List</title>
    <link href="https://chris81051.github.io/2023/06/29/LeetCode-206-Reverse-Linked-List-Java-Python/"/>
    <id>https://chris81051.github.io/2023/06/29/LeetCode-206-Reverse-Linked-List-Java-Python/</id>
    <published>2023-06-29T08:44:23.000Z</published>
    <updated>2023-06-29T08:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這是一題單向鏈結串列反轉的題目，運用指標的算法，目標是將原本的鏈結串列倒序排列，此演算有使用到一個 while 迴圈，則時間複雜度估 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p></blockquote><blockquote><p>給定一個 <code>head</code> 單向鏈結串列，反轉這個串列，且回傳反轉過後的這個串列。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/reverse-linked-list/description/">https://leetcode.com/problems/reverse-linked-list/description/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p>The number of nodes in the list is the range <code>[0, 5000]</code>.<br><code>5000 &lt;= Node.val &lt;= 5000</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><div style="display:inline-block;"> <img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="Reverse" style="float: left; margin-right: 10px;"> </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><div style="display:inline-block;"> <img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="Reverse" style="float: left; margin-right: 10px;"> </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>鏈結串列的題目，簡單想像是在處理節點的位置，資料先放一邊別去裡他。<br>這裡設定三個指標分別是指向 null 的 (指標一)、指向當前 head 的 (指標二)、輔助指標 nextNode (指標三)。</p><blockquote><ul><li>設定好三個指標後</li><li>把當前的 <code>curr.next</code> 掛在輔助指標 nextNode 上 (確保在反轉的過程中不會失去原始下一個節點的位置)</li><li>掛完之後把當前節點 <code>curr.next</code> 指向 prev (此時指針已反轉了)</li><li>接下來移動指針 prev 到 curr</li><li>將 curr 掛在 nextNode (剛剛保存的原始下一個節點的位置)</li><li>以上邏輯循環到最後，當 curr 移動到 null 時則停止迴圈 (鏈結串列的末端節點一定會指向 null)</li></ul></blockquote><p>[補充] <code>curr.next</code> 同等於 <code>curr → link</code> (指向下一個節點的意思)</p><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head; <span class="comment">// 當前指標 (指標一)</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 空集合指標 (指標二)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 檢查確定鏈結串列裡有資料</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> curr.next; <span class="comment">// 輔助指標 (指標三)，指向下一個節點 (資料暫存在輔助指標內)</span></span><br><span class="line">            curr.next = prev; <span class="comment">// 將 curr 的 next 指針指向 prev，(將當前節點的指針方向反轉)</span></span><br><span class="line">            prev = curr; <span class="comment">// 更新指針指向：將 prev 設為 curr</span></span><br><span class="line">            curr = nextNode; <span class="comment">// curr 設為 nextNode</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。<br>(Python 中不需要再宣告一個額外的變數來存儲原始的鏈結串列)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        prev = <span class="literal">None</span> <span class="comment"># 空集合指標 (指標一)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nextNode = head.<span class="built_in">next</span> <span class="comment"># 輔助指標 (指標二)</span></span><br><span class="line">            head.<span class="built_in">next</span> = prev <span class="comment"># 反轉</span></span><br><span class="line">            prev = head <span class="comment"># 移動指標</span></span><br><span class="line">            head = nextNode <span class="comment"># 掛回去原本的鏈結串列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>0ms</td><td>41.8MB</td></tr><tr><td>Python</td><td>53ms</td><td>17.9MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這是一題單向鏈結串列反轉的題目，運用指標的算法</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Linked List" scheme="https://chris81051.github.io/categories/LeetCode/Linked-List/"/>
    
    <category term="Easy" scheme="https://chris81051.github.io/categories/LeetCode/Linked-List/Easy/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 11. Container With Most Water</title>
    <link href="https://chris81051.github.io/2023/06/26/LeetCode-11-Container-With-Most-Water-Java-Python/"/>
    <id>https://chris81051.github.io/2023/06/26/LeetCode-11-Container-With-Most-Water-Java-Python/</id>
    <published>2023-06-26T09:32:07.000Z</published>
    <updated>2023-06-26T09:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題是一個運用雙指標的算法，目標是找到可裝最多水的容器 (面積)，只需一個 while 迴圈就可依依遍歷到最大的面積答案，時間複雜度可估 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.<br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br>Return <em>the maximum amount of water a container can store</em>.<br><strong>Notice</strong> that you may not slant the container.</p></blockquote><blockquote><p>給定一個長度為 <code>n</code> 的整數陣列 <code>height</code> ，畫了 n 條的垂直線，第 i 條線的兩個端點是 (i, 0) 和 (i, height[i])<br>找到兩條線與方向 x 軸一起形成的容器，使得這個容器包含最多的水<br>回傳可裝最大容量的水的容器<br>注意 你不行傾斜容器</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>n == height.length</code><br><code>2 &lt;= n &lt;= 105</code><br><code>0 &lt;= height[i] &lt;= 104</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><div style="display:inline-block;"> <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="Container With Most Water" style="float: left; margin-right: 10px;"> </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br><span class="line">Explanation: The above vertical lines are represented by array [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]. In <span class="built_in">this</span> <span class="keyword">case</span>, the max area of <span class="title function_">water</span> <span class="params">(blue section)</span> the container can contain is <span class="number">49.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>這題題目要我們做的是，在一個陣列裡取出兩個元素後，找出兩個元素相乘後的最大面積，使用的是雙指標算法。</p><blockquote><ul><li>我們思考一下，算出容器的面積會需要的是高度和寬度</li><li>設定高度，取用於陣列裡各個元素的值</li><li>另一方面制定兩個指標，分別為 <code>left</code> 和 <code>right</code>，是要來代表容器的寬度</li><li>並將 <code>left = 0</code> 作為寬度的起始點 (指標一)</li><li>另外把 <code>right = height.length - 1</code> 作為寬度的結束點 (指標二)</li><li>然後運用 while 遍歷陣列，來找出最大的容器</li><li>如果 <code>left</code> 比 <code>right</code> 矮的時候，代表需要找到下一個比較高的容器高度，要 <code>left++</code></li><li>如果 <code>right</code> 比 <code>left</code> 矮的時候，代表需要找到前一個比較高的容器高度，要 <code>left--</code></li><li>如果 <code>right</code> 等於 <code>left</code> 的時候，代表前後一起作用把容器縮小，要 <code>right++</code> 和 <code>left--</code></li></ul></blockquote><p>[補充] 從矮牆開始取得，是因為裝水的時候基準會落在矮牆，超過矮牆的話水會溢出來，思考一下如果一個容器一邊高一邊低，水最多可以裝到哪? 當然最多只能裝到矮牆的最頂端，高牆就並不太重要了，取決於還是矮牆。</p><h3 id="簡易示意圖"><a href="#簡易示意圖" class="headerlink" title="簡易示意圖"></a>簡易示意圖</h3><hr><p>下述循環只演示到第三次，後續動作都是一樣的邏輯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>          |                             |</span><br><span class="line"><span class="number">7</span>          |                             |           |</span><br><span class="line"><span class="number">6</span>          |     |                       |           |</span><br><span class="line"><span class="number">5</span>          |     |           |           |           |</span><br><span class="line"><span class="number">4</span>          |     |           |     |     |           |</span><br><span class="line"><span class="number">3</span>          |     |           |     |     |     |     |</span><br><span class="line"><span class="number">2</span>          |     |     |     |     |     |     |     |</span><br><span class="line"><span class="number">1</span>    |     |     |     |     |     |     |     |     |</span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span></span><br><span class="line">    left                                           <span class="type">right</span></span><br><span class="line"></span><br><span class="line"><span class="variable">w</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">h = <span class="number">1</span></span><br><span class="line">area = <span class="number">8</span> * <span class="number">1</span> = <span class="number">8</span></span><br><span class="line">max = <span class="number">0</span> 更新為 <span class="number">8</span></span><br><span class="line">left &lt; right，left++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>          |                             |</span><br><span class="line"><span class="number">7</span>          |                             |           |</span><br><span class="line"><span class="number">6</span>          |     |                       |           |</span><br><span class="line"><span class="number">5</span>          |     |           |           |           |</span><br><span class="line"><span class="number">4</span>          |     |           |     |     |           |</span><br><span class="line"><span class="number">3</span>          |     |           |     |     |     |     |</span><br><span class="line"><span class="number">2</span>          |     |     |     |     |     |     |     |</span><br><span class="line"><span class="number">1</span>    |     |     |     |     |     |     |     |     |</span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span></span><br><span class="line">          left                                     <span class="type">right</span></span><br><span class="line"></span><br><span class="line"><span class="variable">w</span> <span class="operator">=</span> <span class="number">7</span></span><br><span class="line">h = <span class="number">7</span></span><br><span class="line">area = <span class="number">7</span> * <span class="number">7</span> = <span class="number">49</span></span><br><span class="line">max = <span class="number">8</span> 更新為 <span class="number">49</span></span><br><span class="line">left &lt; right，right--</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>          |                             |</span><br><span class="line"><span class="number">7</span>          |                             |           |</span><br><span class="line"><span class="number">6</span>          |     |                       |           |</span><br><span class="line"><span class="number">5</span>          |     |           |           |           |</span><br><span class="line"><span class="number">4</span>          |     |           |     |     |           |</span><br><span class="line"><span class="number">3</span>          |     |           |     |     |     |     |</span><br><span class="line"><span class="number">2</span>          |     |     |     |     |     |     |     |</span><br><span class="line"><span class="number">1</span>    |     |     |     |     |     |     |     |     |</span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span></span><br><span class="line">          left                               <span class="type">right</span></span><br><span class="line"></span><br><span class="line"><span class="variable">w</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line">h = <span class="number">3</span></span><br><span class="line">area = <span class="number">6</span> * <span class="number">3</span> = <span class="number">18</span></span><br><span class="line">max 不變，一樣是 <span class="number">49</span></span><br><span class="line">left &gt; right，left++</span><br></pre></td></tr></table></figure><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><p>最簡單的是暴力解，就是把一個一個的面積遍歷出來比較，不過想當然兒送出結果跳出 Time Limit Exceeded 超過時間複雜度限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大面積</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;height.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;height.length; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">erea</span> <span class="operator">=</span> (j-i) * Math.min(height[i], height[j]); <span class="comment">// 寬度 * 最小高度</span></span><br><span class="line">                <span class="keyword">if</span> (erea&gt;max)&#123;</span><br><span class="line">                    max = erea; <span class="comment">// 設定最大面積</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比較聰明的算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指標一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>; <span class="comment">// 指標二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大的面積</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> right - left; <span class="comment">// 算出寬度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[left], height[right]); <span class="comment">// 算出高度 (從最矮的開始)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> h * w; <span class="comment">// 算出面積</span></span><br><span class="line">            max = Math.max(max, area); <span class="comment">// 存入最大的面積</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++; <span class="comment">// 找下一個比較大的元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(height[left] &gt; height[right]) &#123;</span><br><span class="line">                right--; <span class="comment">// 找前一個比較大的元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前後一起縮小</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># 指標一</span></span><br><span class="line">        right = <span class="built_in">len</span>(height) - <span class="number">1</span> <span class="comment"># 指標二</span></span><br><span class="line">        max_area = <span class="number">0</span> <span class="comment"># 最大的面積</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line"></span><br><span class="line">            w = right - left <span class="comment"># 算出寬度</span></span><br><span class="line">            h = <span class="built_in">min</span>(height[left], height[right]) <span class="comment"># 算出高度 (從最矮的開始)</span></span><br><span class="line">            area = w * h <span class="comment"># 算出面積</span></span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, area) <span class="comment"># 存入最大的面積</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 找下一個比較大的元素</span></span><br><span class="line">            <span class="keyword">elif</span> height[left] &gt; height[right]:</span><br><span class="line">                right -= <span class="number">1</span> <span class="comment"># 找前一個比較大的元素</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 前後一起縮小</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>5ms</td><td>55.8MB</td></tr><tr><td>Python</td><td>744ms</td><td>28.4MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">要如何找到可裝最多水的容器呢 (面積)</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Greedy" scheme="https://chris81051.github.io/tags/Greedy/"/>
    
    <category term="Two Pointers" scheme="https://chris81051.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 15. 3Sum</title>
    <link href="https://chris81051.github.io/2023/06/16/LeetCode-15-3Sum-Java-Python/"/>
    <id>https://chris81051.github.io/2023/06/16/LeetCode-15-3Sum-Java-Python/</id>
    <published>2023-06-16T08:46:22.000Z</published>
    <updated>2023-06-16T08:46:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題是一個運用指標的算法，而且是用三個指標來追蹤，運用指標依序掃瞄出題目所要的元素並加起來，使用到了 for、while 兩個迴圈，時間複雜度估達 <code>O(n²)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.<br>Notice that the solution set must not contain duplicate triplets.</p></blockquote><blockquote><p>給定一個整數陣列 nums，回傳所有的三元組，其中 <code>i != j</code>, <code>i != k</code>, <code>j != k</code>，且三元組全部加起來等於 0。<br>注意 這個解決方案必須不含重複的三元組。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>3 &lt;= nums.length &lt;= 3000</code><br><code>105 &lt;= nums[i] &lt;= 105</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">4</span>]</span><br><span class="line">Output: [[-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = (-<span class="number">1</span>) + <span class="number">0</span> + <span class="number">1</span> = <span class="number">0.</span></span><br><span class="line">nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + nums[<span class="number">4</span>] = <span class="number">0</span> + <span class="number">1</span> + (-<span class="number">1</span>) = <span class="number">0.</span></span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">3</span>] + nums[<span class="number">4</span>] = (-<span class="number">1</span>) + <span class="number">2</span> + (-<span class="number">1</span>) = <span class="number">0.</span></span><br><span class="line">The distinct triplets are [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] and [-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The only possible triplet does not sum up to <span class="number">0.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">Output: [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">Explanation: The only possible triplet sums up to <span class="number">0.</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>直觀的作法是設定三個指標來掃描，第一個指標先不動，另外兩個指標依序掃描元素，掃描後把全部的元素加起來，判斷裡面的合有沒有等於 0 的，有的話就加入在要輸出的陣列裡，資料結構想到的是把陣列裡的元素個別放進集合裡，再將每一組串列集合放進 <code>HashSet</code> 大集合裡，<code>HashSet</code> 好處是可過濾掉重複的組合。</p><blockquote><ul><li>將 Array 從小到大排序</li><li>找出三個數的指標分別表示為 <code>i</code>、<code>j</code>、<code>k</code></li><li>使用迴圈遍歷，並將 <code>i</code> 做為 <code>nums</code> 的起始點 (指標一)</li><li><code>j</code> 則為 <code>i + 1</code> 為起始 (指標二)</li><li><code>k</code> 則為 <code>nums.Length - 1</code> 為起始點 (指標三)</li><li>首先以 <code>i</code> 為準，從 <code>j</code> 開始掃描到 <code>k</code> 算一輪</li><li>並判斷三個指標指向的元素 <code>nums[i] + nums[j] + nums[k]</code> 加起來的合是否為 0 ，是的話會把此組合加進串列集合內</li><li>之後讓 <code>j</code> 前進一格，<code>K</code> 後退一格，來排除重複的組合找到下一個組合</li><li>由於元素從小排到大，當 <code>sum &lt; target</code> 的話，表示說我們的 <code>j</code> 要繼續往右掃描到一個更大的元素，加起來的合再做判斷</li><li>那元素從小排到大，當 <code>sum &gt; target</code> 的話，表示說我們的 k 要繼續往左掃描到一個更小的元素，加起來的合再做判斷</li></ul></blockquote><p>[備註] 使用 <code>HashSet</code> 是為了確保集合裡的資料不重複</p><h3 id="簡易示意圖"><a href="#簡易示意圖" class="headerlink" title="簡易示意圖"></a>簡易示意圖</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|  i  |  j  |     |     |     |  k  |</span><br><span class="line"></span><br><span class="line">sum = (-<span class="number">4</span>) + (-<span class="number">1</span>) + <span class="number">2</span> = -<span class="number">3</span></span><br><span class="line">sum &lt; <span class="number">0</span>，j++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|  i  |     |  j  |     |     |  k  |</span><br><span class="line"></span><br><span class="line">sum = (-<span class="number">4</span>) + (-<span class="number">1</span>) + <span class="number">2</span> = -<span class="number">3</span></span><br><span class="line">sum &lt; <span class="number">0</span>，j++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|  i  |     |     |  j  |     |  k  |</span><br><span class="line"></span><br><span class="line">sum = (-<span class="number">4</span>) + <span class="number">0</span> + <span class="number">2</span> = -<span class="number">2</span></span><br><span class="line">sum &lt; <span class="number">0</span>，j++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|  i  |     |     |     |  j  |  k  |</span><br><span class="line"></span><br><span class="line">sum = (-<span class="number">4</span>) + <span class="number">1</span> + <span class="number">2</span> = -<span class="number">1</span></span><br><span class="line">sum &lt; <span class="number">0</span>，j++</span><br><span class="line">j == k，回到最新一輪，i++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|     |  i  |  j  |     |     |  k  |</span><br><span class="line"></span><br><span class="line">sum = (-<span class="number">1</span>) + (-<span class="number">1</span>) + <span class="number">2</span> = <span class="number">0</span>，加進集合</span><br><span class="line">j++</span><br><span class="line">k--</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|     |  i  |     |  j  |  k  |     |</span><br><span class="line"></span><br><span class="line">sum = (-<span class="number">1</span>) + <span class="number">0</span> + <span class="number">1</span> = <span class="number">0</span>，加進集合</span><br><span class="line">j++</span><br><span class="line">k--</span><br><span class="line">j &gt; k，回到最新一輪，i++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|     |     |  i  |  j  |     |  k  |</span><br><span class="line"></span><br><span class="line">i 與上次相同，回到最新一輪，i++</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| -<span class="number">4</span>  | -<span class="number">1</span>  | -<span class="number">1</span>  |  <span class="number">0</span>  |  <span class="number">1</span>  |  <span class="number">2</span>  |</span><br><span class="line">|-----|-----|-----|-----|-----|-----|</span><br><span class="line">|     |     |     |  i  |  j  |  k  |</span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span> + <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 目標整數</span></span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 從小到大排序 (原Array)</span></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 存元素</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 輸出用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; <span class="comment">// 指標二</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 指標三</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k]; <span class="comment">// 指標全加起來</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="comment">// 將陣列元素轉成集合再加到大集合內</span></span><br><span class="line">                    s.add(Arrays.asList(nums[i], nums[j], nums[k])); <span class="comment">// 類似這樣的資料結構 [[1, 2, 3], [2, 3, 4]]</span></span><br><span class="line">                    <span class="comment">// 縮小範圍</span></span><br><span class="line">                    j++; </span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    j++; <span class="comment">// 找更大的元素</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    k--; <span class="comment">// 找更小的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output.addAll(s); <span class="comment">// 集合加到陣列裡</span></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        </span><br><span class="line">        target = <span class="number">0</span> <span class="comment"># 目標整數</span></span><br><span class="line">        nums.sort() <span class="comment"># 從小到大排序 (原Array)</span></span><br><span class="line">        s = <span class="built_in">set</span>() <span class="comment"># 存元素的集合</span></span><br><span class="line">        output = [] <span class="comment"># 輸出用的陣列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i + <span class="number">1</span> <span class="comment"># 指標二</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="comment"># 指標三</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                total = nums[i] + nums[j] + nums[k] <span class="comment"># 指標全加起來</span></span><br><span class="line">                <span class="keyword">if</span> total == target:</span><br><span class="line">                    s.add((nums[i], nums[j], nums[k])) <span class="comment"># 將陣列元素加到集合內</span></span><br><span class="line">                    <span class="comment"># 縮小範圍</span></span><br><span class="line">                    j = j+<span class="number">1</span> </span><br><span class="line">                    k = k-<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                    j = j+<span class="number">1</span> <span class="comment"># 找更大的元素</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = k-<span class="number">1</span> <span class="comment"># 找更小的元素</span></span><br><span class="line">        </span><br><span class="line">        output.extend(<span class="built_in">list</span>(s)) <span class="comment"># 添加進陣列</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>706ms</td><td>50.8MB</td></tr><tr><td>Python</td><td>2857ms</td><td>20.2MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題是一個運用指標的算法，而且是用三個指標來追蹤</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Two Pointers" scheme="https://chris81051.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 53. Maximum Subarray</title>
    <link href="https://chris81051.github.io/2023/05/31/LeetCode-53-Maximum-Subarray-Java-Python/"/>
    <id>https://chris81051.github.io/2023/05/31/LeetCode-53-Maximum-Subarray-Java-Python/</id>
    <published>2023-05-31T09:27:48.000Z</published>
    <updated>2023-05-31T09:27:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題是一個經典的動態規劃問題，目標是找到一個陣列中連續子陣列的合還有回傳最大值，時間複雜度可達 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an integer array <code>nums</code>, find the subarray with the largest sum, and return its sum.</p></blockquote><blockquote><p>給定一個整數陣列 <code>nums</code> ，找到最大總合的子陣列，然後回傳子陣列的總合。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= nums.length &lt;= 105</code><br><code>104 &lt;= nums[i] &lt;= 104</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: The subarray [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum <span class="number">6.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The subarray [<span class="number">1</span>] has the largest sum <span class="number">1.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">5</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">Output: <span class="number">23</span></span><br><span class="line">Explanation: The subarray [<span class="number">5</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>] has the largest sum <span class="number">23.</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>直觀的做法是把元素依依累加下去，這也代表為連續的子陣列，然後再將這個子陣列相加的最大數存起來。</p><blockquote><ul><li>遍歷索引累加下去，子陣列的合會越來越大，代表此子陣列的合上限一直在增加。(這樣可以確保當前子陣列的總合是連續的，且是最大的值)</li><li>再來比較子陣列的合跟最大值，更新到最大的值。</li><li>後續要判斷相加的合如果小於 0 的話，重新找子陣列的起點，再依依累加下去。</li><li>因為子陣列的合為負數，表示對後續的合沒有貢獻，將其重置為 0。(假如是負數的話對於子陣列的合會被扣掉)</li></ul></blockquote><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length; <span class="comment">// 陣列的長度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 確保整數為最小值 (有可能比0還要小)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子陣列的合</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">            sum += nums[i]; <span class="comment">// 子陣列的合 + 當下索引的值</span></span><br><span class="line">            max = Math.max(sum,max); <span class="comment">// 子陣列的合、最大值，取比較大的數</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>; <span class="comment">// 子陣列的合重製為 0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max; <span class="comment">// 回傳最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums) <span class="comment"># 陣列長度</span></span><br><span class="line">        current_sum = <span class="number">0</span> <span class="comment"># 子陣列的合</span></span><br><span class="line">        current_max = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>) <span class="comment"># 確保是最小的整數</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">            current_sum += nums[i] <span class="comment"># 子陣列的合 + 當下索引的值</span></span><br><span class="line">            current_max = <span class="built_in">max</span>(current_sum, current_max) <span class="comment"># 子陣列的合、最大值，取比較大的數</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current_sum&lt;<span class="number">0</span>):  </span><br><span class="line">                current_sum = <span class="number">0</span> <span class="comment"># 子陣列的合重製為 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_max <span class="comment"># 回傳最大數</span></span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>1ms</td><td>59.1MB</td></tr><tr><td>Python</td><td>719ms</td><td>30.6MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題是一個經典的動態規劃問題，目標是找到一個陣列中連續子陣列的合還有回傳最大值</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Medium" scheme="https://chris81051.github.io/categories/LeetCode/Array/Medium/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Dynamic Programming" scheme="https://chris81051.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 704. Binary Search</title>
    <link href="https://chris81051.github.io/2023/05/29/LeetCode-704-Binary-Search-Java-Python/"/>
    <id>https://chris81051.github.io/2023/05/29/LeetCode-704-Binary-Search-Java-Python/</id>
    <published>2023-05-29T07:39:18.000Z</published>
    <updated>2023-05-29T07:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題用的技巧是二分搜尋法，原理是每次循環都會將搜索範圍縮小一半。演算法通常需要使用二分思想，即每次能夠排除一半的範圍，快速的找出陣列中所要求的元素位置，這樣時間複雜度可達 <code>O(log n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.<br>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p></blockquote><blockquote><p>給定一個整數陣列 <code>nums</code> ，這是個上升排序陣列，和一個目標整數 <code>target</code> ，寫一個方法去搜尋在 <code>nums</code> 陣列裡的目標整數 <code>target</code> 。如果目標整數 <code>target</code> 存在就回傳這個索引。否則回傳 <code>-1</code>。<br>你必須寫一個時間複雜度是 <code>O(log n)</code> 的演算法。 </p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/binary-search/">https://leetcode.com/problems/binary-search/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= numRows &lt;= 30</code><br><code>1 &lt;= nums.length &lt;= 104</code><br><code>104 &lt; nums[i], target &lt; 104</code><br>All the integers in <code>nums</code> are <strong>unique</strong>.<br><code>nums</code> is sorted in ascending order.</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: <span class="number">9</span> exists in nums and its index is <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">Output: -<span class="number">1</span></span><br><span class="line">Explanation: <span class="number">2</span> does not exist in nums so <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>這題用的技巧是二分搜尋法，原理是每次循環都會將搜索範圍縮小一半。</p><blockquote><ol><li>middle &#x3D; start + ( end - start ) &#x2F; 2 可取得中間值</li><li>找出目標值在中間值的左側還是右側</li><li>搜索範圍越來越小，直到最後回傳中間值就是答案</li></ol></blockquote><p>[注意點] 之所以要用上述中間值的寫法會比較安全，因如果 start 和 end 趨近於最大數時，兩者相加起來的合可能會造成整數溢位</p><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 起點位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>; <span class="comment">// 終點位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> start + (end-start)/<span class="number">2</span>; <span class="comment">// 中間值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[middle])&#123; <span class="comment">// 目標值 &gt; 陣列中間值 </span></span><br><span class="line">                start = middle + <span class="number">1</span>; <span class="comment">// 重新定義起點，下次回圈從新的起點開始就好 (因為目標值一定比自己大，要不包含 middle 自己)</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle])&#123; <span class="comment">// 目標值 &lt; 陣列中間值 </span></span><br><span class="line">                end = middle - <span class="number">1</span>; <span class="comment">// 重新定義終點，下次回圈找到新的終點就好 (因為目標值一定比自己小，要不包含 middle 自己)</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 目標值 = 陣列中間值</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 找到答案，回傳中間值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 沒有這個數回傳 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span> <span class="comment"># 起點</span></span><br><span class="line">        end = <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="comment"># 終點</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 設定中間值</span></span><br><span class="line">            middle = start + (end-start)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判斷 target 是否大於</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[middle]:</span><br><span class="line">                start = middle+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判斷 target 是否小於</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[middle]:</span><br><span class="line">                end = middle-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判斷 target 是否等於 middle</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 都沒有</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>0ms</td><td>45.1MB</td></tr><tr><td>Python</td><td>251ms</td><td>17.9MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題用的技巧是二分搜尋法，原理是每次循環都會將搜索範圍縮小一半。</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Easy" scheme="https://chris81051.github.io/categories/LeetCode/Array/Easy/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Binary Search" scheme="https://chris81051.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 118. Pascal&#39;s Triangle</title>
    <link href="https://chris81051.github.io/2023/05/28/LeetCode-118-Pascal-s-Triangle-Java-Python/"/>
    <id>https://chris81051.github.io/2023/05/28/LeetCode-118-Pascal-s-Triangle-Java-Python/</id>
    <published>2023-05-28T09:53:21.000Z</published>
    <updated>2023-05-28T09:53:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題的大方向是要如何找到上一行的上一列的元素來做兩兩相加的運算，像是動態規劃的邏輯思考，需要用到雙迴圈的關係，時間複雜度達 <code>O(n²)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.<br>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p></blockquote><blockquote><p>給定一個整數 <code>numRows</code>，回傳一個相對應層數的帕斯卡三角形。<br>在帕斯卡三角形裡遍歷的每個數字，都是其上方兩個數的合：</p></blockquote><div style="display:inline-block;"> <img width="100%" src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="Your Image" style="float: left; margin-right: 10px;"> </div><p>題目連結：<a href="https://leetcode.com/problems/pascals-triangle/">https://leetcode.com/problems/pascals-triangle/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= numRows &lt;= 30</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows = <span class="number">5</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows = <span class="number">1</span></span><br><span class="line">Output: [[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>這題的大方向是要如何找到上一行的上一列的元素來做兩兩相加的運算，像是動態規劃的邏輯思考。</p><blockquote><ul><li>首先我們把帕斯卡三角形想像成一個大型的 List，再把這個大型的 List 裡的每個元素放入個別 List 裡來當作每一列。</li><li>已經有了兩個要件，接著用雙迴圈去遍歷大型的 List 裡的每一列放我們要放的元素。</li><li>可是不要忘了要判斷每一列的頭跟尾都要是 1 才能把對的元素放在對位置。</li><li>解決頭尾已經是 1 了，再把前一列的兩值加起來後依依放進去。 (這邊要注意，因我們用的是 ArrayList 類，需要用 <code>.get()</code> 方法來取得元素的位置)</li><li>最後把每一列放入大型的 List 裡。</li></ul></blockquote><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 創建二維列表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 為了防止無效輸入，直接回傳一個空的列表</span></span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            <span class="comment">// 每一列</span></span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 如果第一行要生成數字，j&lt;i =&gt; 0&lt;0 無法成立，i 應要 +1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++)&#123; </span><br><span class="line">                <span class="comment">// 判斷 list 的頭尾 (到了第5行要總生成5個數字，最後一個數字)</span></span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==i)&#123;</span><br><span class="line">                    row.add(<span class="number">1</span>); <span class="comment">// 是 0 的話插入 1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 因要從二維列表取值，從第 i-1 行中取得第 j-1 的元素</span></span><br><span class="line">                    row.add(nums.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>) + nums.get(i-<span class="number">1</span>).get(j)); <span class="comment">// 把前一列的兩值加起來</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums.add(row); <span class="comment">// 把列表插入二維列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = [] <span class="comment"># 大三角形</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            row = [] <span class="comment"># 每行</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">or</span> j==i: <span class="comment"># 判斷頭尾</span></span><br><span class="line">                    row.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row.append(nums[i-<span class="number">1</span>][j-<span class="number">1</span>] + nums[i-<span class="number">1</span>][j]) <span class="comment"># 把前一列的兩值加起來</span></span><br><span class="line">            nums.append(row)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>1ms</td><td>41.1MB</td></tr><tr><td>Python</td><td>48ms</td><td>16.3MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題的大方向是要如何找到上一行的上一列的元素來做兩兩相加的運算，像是動態規劃的邏輯思考。</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Easy" scheme="https://chris81051.github.io/categories/LeetCode/Array/Easy/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Dynamic Programming" scheme="https://chris81051.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 35. Search Insert Position</title>
    <link href="https://chris81051.github.io/2023/05/17/LeetCode-35-Search-Insert-Position-Java-Python/"/>
    <id>https://chris81051.github.io/2023/05/17/LeetCode-35-Search-Insert-Position-Java-Python/</id>
    <published>2023-05-17T06:59:31.000Z</published>
    <updated>2023-05-17T06:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題標準運用了二分搜尋法，演算法通常需要使用二分思想，即每次能夠排除一半的範圍，快速的找出陣列中所要求的元素位置，這樣時間複雜度可達 <code>O(log n)</code>，另外也可以使用一層迴圈找出元素位置，但時間複雜度會下修到<code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p></blockquote><blockquote><p>給定一個已排序過有不同整數和目標值的陣列，如果有這個目標值就回傳這個索引 ，如果沒有這個值，就回傳按順序插入後的索引。<br>你必須寫出一個算法，為 <code>O(log n)</code> 的時間複雜度。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/search-insert-position/">https://leetcode.com/problems/search-insert-position/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= nums.length &lt;= 104</code><br><code>104 &lt;= nums[i] &lt;= 104</code><br><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.<br><code>104 &lt;= target &lt;= 104</code></p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">5</span></span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">7</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>主要是運用二分搜尋法來快速的找到值的位置，原理是每次循環都會將搜索範圍縮小一半。<br>如果 target 比中間值大，那麼搜索範圍將在中間值的右側。<br>如果 target 比中間值小，那麼搜索範圍將在中間值的左側。</p><blockquote><ol><li>middle &#x3D; start + ( end - start ) &#x2F; 2 可取得中間值</li><li>找出目標值在中間值的左側還是右側</li><li>搜索範圍越來越小，直到最後回傳起點位置就是答案</li></ol></blockquote><p><strong>[注意點]</strong> 之所以要用上述中間值的寫法會比較安全，因如果 start 和 end 趨近於最大數時，兩者相加起來的合可能會造成整數溢位</p><p><strong>[備註]</strong> 回傳 start 原因是，在二分搜尋法中，每次都會將搜索範圍縮小一半。而搜尋範圍最小的時候，如果目標值不在該範圍內，那麼搜尋將停止。而此時，start 和 end 分別會指向搜尋範圍的左右兩端，此時 start 恰好會指向 target 應該插入的位置，因此最後返回 start 即可。</p><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 起點位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>; <span class="comment">// 終點位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 進入迴圈</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 創建中間值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> start + ( end - start ) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target == nums[middle]) &#123; <span class="comment">// 目標值 = 陣列中間值</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 找到答案，回傳中間值索引</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123; <span class="comment">// 目標值 &lt; 陣列中間值 </span></span><br><span class="line">                end = middle-<span class="number">1</span>; <span class="comment">// 重新定義終點，下次回圈找到新的終點就好 (因為目標值一定比自己小，要不包含 middle 自己)</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 目標值 &gt; 陣列中間值 </span></span><br><span class="line">                start = middle+<span class="number">1</span>; <span class="comment">// 重新定義起點，下次回圈從新的起點開始就好 (因為目標值一定比自己大，要不包含 middle 自己)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA-其他實現"><a href="#JAVA-其他實現" class="headerlink" title="JAVA 其他實現"></a>JAVA 其他實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length; <span class="comment">// 陣列長度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= target) &#123; <span class="comment">// 大於等於目標值</span></span><br><span class="line">                <span class="keyword">return</span> i; <span class="comment">// 就回傳當前索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span> <span class="comment"># 起點</span></span><br><span class="line"></span><br><span class="line">        end = <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="comment"># 終點</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 設定中間值</span></span><br><span class="line">            middle = start + (end-start)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判斷 target 是否等於 middle</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[middle]:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判斷 target 是否大於</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[middle]:</span><br><span class="line">                start = middle+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判斷 target 是否小於</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                end = middle-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>0ms</td><td>41.9MB</td></tr><tr><td>Python</td><td>63ms</td><td>17.2MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">這題標準運用了二分搜尋法，演算法通常需要使用二分思想，即每次能夠排除一半的範圍，快速的找出陣列中所要求的元素位置</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Easy" scheme="https://chris81051.github.io/categories/LeetCode/Array/Easy/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Binary Search" scheme="https://chris81051.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 283. Move Zeroes</title>
    <link href="https://chris81051.github.io/2023/05/05/LeetCode-283-Move-Zeroes-Java-Python/"/>
    <id>https://chris81051.github.io/2023/05/05/LeetCode-283-Move-Zeroes-Java-Python/</id>
    <published>2023-05-05T07:03:14.000Z</published>
    <updated>2023-05-05T07:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>　　這題題目要設法將陣列中的非零元素全部往前移，題目要求不能配置新的空間，所以不能使用輔助的 Array，那我們就由本身的陣列來做循環添加，這是比較簡單的方法，需用到一層迴圈，時間複雜度推估可達 <code>O(n)</code>，這裡有 JAVA 和 Python 的寫法。</p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><hr><blockquote><p>Given an integer array <strong>nums</strong>, move all <strong>0</strong>‘s to the end of it while maintaining the relative order of the <strong>non-zero</strong> elements.<br><strong>Note</strong> that you must do this in-place without making a copy of the array.</p></blockquote><blockquote><p>給定一個整數陣列為 <strong>nums</strong>，移動全部的 <strong>零</strong> 元素到最後面， 同時維持 <strong>非零</strong> 元素的原本順序。<br>注意 你必須在當前陣列做，不能複製一個陣列來做。</p></blockquote><p>題目連結：<a href="https://leetcode.com/problems/move-zeroes/">https://leetcode.com/problems/move-zeroes/</a></p><h3 id="題目限制"><a href="#題目限制" class="headerlink" title="題目限制"></a>題目限制</h3><hr><p><code>1 &lt;= nums.length &lt;= 104</code><br><code>231 &lt;= nums[i] &lt;= 231 - 1</code></p><p><strong>Follow up:</strong> Could you minimize the total number of operations done?</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">0</span>]</span><br><span class="line">Output: [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="思路-amp-筆記"><a href="#思路-amp-筆記" class="headerlink" title="思路&amp;筆記"></a>思路&amp;筆記</h3><hr><p>題目要求不能配置新的空間，所以不能用輔助的 Array，那我們就由本身陣列來做循環添加。</p><blockquote><ul><li>把非零元素加到當前陣列裡</li><li>從陣列的最前面開始添加，索引從 0 開始 (從陣列的最前面)</li><li>再把當前的陣列後面補 0 即可，索引從 3 開始 (從剛添加完非零元素後面開始)</li></ul></blockquote><h3 id="JAVA-實現"><a href="#JAVA-實現" class="headerlink" title="JAVA 實現"></a>JAVA 實現</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 防止這個函式會直接回傳傳入的 nums 參數</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把非零元素加到當前陣列裡</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[insert++] = num; <span class="comment">// 從陣列的最前面開始添加 (注意：元素會先被添加在 nums[insert]裡，之後 insert 才會被 ++)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再把當前的陣列後面補 0 即可，索引從 3 開始</span></span><br><span class="line">        <span class="keyword">while</span> (insert &lt; nums.length)&#123;</span><br><span class="line">            nums[insert++] = <span class="number">0</span>; <span class="comment">// 添加 0 進去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h3><hr><p>使用了和 Java 一樣的邏輯執行，換成 Python 的寫法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把非零元素加到當前陣列裡</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] !=<span class="number">0</span>: <span class="comment"># 不是非 0 元素</span></span><br><span class="line">                nums[pointer] = nums[i]  <span class="comment"># 取得當下元素，放到指定索引裡</span></span><br><span class="line">                pointer += <span class="number">1</span> <span class="comment"># 索引++</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再把當前的陣列後面補 0 即可，索引從 3 開始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pointer, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[pointer] = <span class="number">0</span> <span class="comment"># 添加 0 進去</span></span><br><span class="line">            pointer += <span class="number">1</span> <span class="comment"># 索引 ++</span></span><br></pre></td></tr></table></figure><h3 id="Python-進階實現"><a href="#Python-進階實現" class="headerlink" title="Python 進階實現"></a>Python 進階實現</h3><hr><p>筆者還在學習中，參考了在討論區裡網友討論度很高的 Swap 變數互換 簡潔的算法。</p><blockquote><ul><li>把陣列中前面的元素和後面的元素設定好條件 (必須前面為非零元素，後面為零元素)</li><li>將兩個元素做交換，把非零元素換到前面</li><li>最後後面索引 +1，進行下一次比較交換元素</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        slow = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span> <span class="keyword">and</span> nums[slow] == <span class="number">0</span>: <span class="comment"># 前面的元素、後面的元素</span></span><br><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow] <span class="comment"># 將兩個元素做交換</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第一次循環，剛開始索引 fast[0] slow[0]</span></span><br><span class="line">            <span class="keyword">if</span> nums[slow] != <span class="number">0</span>: </span><br><span class="line">                slow += <span class="number">1</span> <span class="comment"># 索引 +1 後，換比較交換 fast[1] ，slow[2]</span></span><br></pre></td></tr></table></figure><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><hr><p>雙指針算法：<a href="https://medium.com/@urdreamliu/283-%E5%9C%96%E8%A7%A3-move-zeroes-4da4900f5aac">https://medium.com/@urdreamliu/283-圖解-move-zeroes-4da4900f5aac</a></p><h3 id="成績"><a href="#成績" class="headerlink" title="成績"></a>成績</h3><hr><table><thead><tr><th>Language</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>1ms</td><td>43.9MB</td></tr><tr><td>Python</td><td>158ms</td><td>17.9MB</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">不配置新的輔助 Array 空間，來移動陣列元素重新排序</summary>
    
    
    
    <category term="LeetCode" scheme="https://chris81051.github.io/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://chris81051.github.io/categories/LeetCode/Array/"/>
    
    <category term="Easy" scheme="https://chris81051.github.io/categories/LeetCode/Array/Easy/"/>
    
    
    <category term="Top 100 Liked Questions" scheme="https://chris81051.github.io/tags/Top-100-Liked-Questions/"/>
    
    <category term="Java" scheme="https://chris81051.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://chris81051.github.io/tags/Python/"/>
    
    <category term="Two Pointers" scheme="https://chris81051.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
</feed>
